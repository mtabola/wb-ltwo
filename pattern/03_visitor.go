package main

import "fmt"

/*
	Посетитель — это поведенческий паттерн проектирования,
	который позволяет создавать новые операции, не меняя классы
	объектов, над которыми эти операции могут выполняться.

	Дописываем дополнительный функционал не изменяя основную структуру
==========================================================
Применимость паттерна "Посетитель":
  - Когда необходимо добавить новые операции к объектам, но изменение их классов нежелательно или невозможно.
  - Когда имеется сложная структура объектов, и необходимо выполнить различные операции над каждым объектом,
    не нарушая инкапсуляцию.


		 Шаги реализации

	 1. Создайте интерфейс посетителя и объявите в нём методы «посещения»
	    для каждого класса компонента, который существует в программе.

	 2. Опишите интерфейс компонентов. Если вы работаете с уже
	    существующими классами, то объявите абстрактный метод принятия
	    посетителей в базовом классе иерархии компонентов.

	 3. Реализуйте методы принятия во всех конкретных компонентах.
	    Они должны переадресовывать вызовы тому методу посетителя,
	    в котором класс параметра совпадает с текущим классом компонента.

	 4. Иерархия компонентов должна знать только о базовом интерфейсе
	    посетителей. С другой стороны, посетители
	    будут знать обо всехклассах компонентов.

	 5. Для каждого нового поведения создайте свой конкретный класс.
	    Приспособьте это поведение для всех посещаемых компонентов,
	    реализовав все методы интерфейса посетителей.

	    Вы можете столкнуться с ситуацией, когда посетителю нужен будет
	    доступ к приватным полям компонентов. В этом случае,
	    вы можете либо раскрыть доступ к этим полям, нарушив
	    инкапсуляцию компонентов, либо сделать класс
	    посетителя вложенным в класс компонента, если вам
	    повезло писать на языке, который поддерживает вложенность классов.
	 6. Клиент будет создавать объекты посетителей,
	    а затем передавать их компонентам, используя метод принятия.


Реальные примеры использования паттерна "Посетитель":
- Обработка документов: Посетитель может использоваться для обработки различных элементов документа, таких как абзацы,
	таблицы, изображения и т.д. Каждый элемент может иметь свою собственную операцию, которую выполняет посетитель.
- Анализ и обработка AST (Abstract Syntax Tree): Посетитель может использоваться для анализа и обработки абстрактного
	синтаксического дерева, которое представляет структуру программы.
- Посещение коллекций объектов: Посетитель может использоваться для выполнения операций над каждым объектом в коллекции,
	не изменяя классы объектов.

============================================================
Преимущества

	 Упрощает добавление новых операций над всей связанной
	структурой объектов.
	 Объединяет родственные операции в одном классе.
	 Посетитель может накоплять состояние при обходе структуры компонентов.

Недостатки

	 Паттерн неоправдан, если иерархия компонентов часто меняется.
	 Может привести к нарушению инкапсуляции компонентов.
*/

// визитер должен реализовать для каждой структуры дополниетльные методы
type VisitorI interface {
	VisitSubaru(s subaru)
	VisitMitsubishi(m mitsubishi)
	VisitBMW(b bmv)
}

// определим интерфейс Машины, что бы каждая структура имела
// функцию доступа к визитеру
type Cars interface {
	Accept(visitor Visitor)
}

// используеться для дополнения структур
type Visitor struct{}

func (v Visitor) VisitSubaru(s *subaru) {
	fmt.Printf("this is Subaru spead %d "+
		"and %f fuel consumption\n", s.speed, s.fuel)
}
func (v Visitor) VisitMitsubishi(m *mitsubishi) {
	fmt.Printf("this is Mitsubishi speed %d "+
		"and %f fuel consumption\n", m.speed, m.fuel)
}
func (v Visitor) VisitBMW(b *bmv) {
	fmt.Printf("this is BMW spead %d "+
		"and %f fuel consumption\n", b.speed, b.fuel)
}

type subaru struct {
	speed int
	fuel  float64
}

func (s *subaru) Accept(visitor Visitor) {
	visitor.VisitSubaru(s)
}

type mitsubishi struct {
	speed int
	fuel  float64
}

func (m *mitsubishi) Accept(visitor Visitor) {
	visitor.VisitMitsubishi(m)
}

type bmv struct {
	speed int
	fuel  float64
}

func (b *bmv) Accept(visitor Visitor) {
	visitor.VisitBMW(b)
}

func main() {
	cars := []Cars{
		&subaru{
			speed: 22,
			fuel:  9.0,
		},
		&mitsubishi{
			speed: 27,
			fuel:  9.9,
		},
		&bmv{
			speed: 22,
			fuel:  12.2,
		},
	}

	visit := Visitor{}
	for _, i := range cars {
		i.Accept(visit)
	}
}

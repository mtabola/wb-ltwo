package main

import "fmt"

/*
	Фабричный метод
	тип: порождающий

  	Фабричный метод (Factory Method) - это паттерн, который предоставляет интерфейс для создания объектов,
	но позволяет подклассам решать, какой класс объекта создавать.
	Он используется, когда у нас есть суперкласс, определяющий общий интерфейс,
	и мы хотим, чтобы подклассы определяли конкретные классы, которые они создают.
	Фабричный метод делегирует создание объектов подклассам, позволяя расширять функциональность
	и добавлять новые типы объектов без изменения кода суперкласса.

	Преимущества
	 Избавляет класс от привязки к конкретным классам
	продуктов.
	 Выделяет код производства продуктов в одно место, упрощая поддержку кода.
	 Упрощает добавление новых продуктов в программу.
	 Реализует принцип открытости/закрытости.

	Недостатки
	 Может привести к созданию больших параллельных иерархий классов,
		так как для каждого класса продукта надо создать свой подкласс создателя.

	 Шаги реализации
	1. Приведите все создаваемые продукты к общему
	интерфейсу.
	2. В классе, который производит продукты, создайте пустой фабричный метод.
		В качестве возвращаемого типа укажите общий интерфейс продукта.
	3. Затем, пройдитесь по коду класса и найдите все участки, создающие продукты.
		Поочерёдно замените эти участки вызовами фабричного метода, перенося в него код создания различных продуктов.
		В фабричный метод, возможно, придётся добавить несколько параметров, контролирующих какой из продуктов нужно создать.
		На этом этапе фабричный метод, скорее всего, будет выглядеть удручающе. В нём будет жить большой условный оператор, выбирающий класс создаваемого продукта. Но не волнуйтесь, мы вот-вот исправим это.
	4. Для каждого типа продуктов заведите подкласс и переопределите в нём фабричный метод.
		Переместите туда код создания соответствующего продукта из суперкласса.
	5. Если создаваемых продуктов слишком много для существующих подклассов создателя, вы можете подумать
		о введении параметров в фабричный метод, которые
		позволят возвращать различные продукты в пределах одного подкласса.
		Например, у вас есть класс Почта с подклассами АвиаПочта и НаземнаяПочта ,
		а также классы продуктов Самолёт , Грузовик и Поезд . Авиа соответствует Самолётам , но для НаземнойПочты есть сразу два продукта.
		Вы могли бы создать новый подкласс почты для поездов, но проблему можно решить и по-другому.
		Клиентский код может передавать в фабричный метод НаземнойПочты аргумент, контролирующий какой из продуктов будет создан.
	6. Если после всех перемещений фабричный метод стал пустым, можете сделать его абстрактным.
		Если в нём что-то осталось — не беда, это будет его реализацией по умолчанию.

	Отличие
	Основное отличие между абстрактной фабрикой и фабричным методом заключается в том,
	что абстрактная фабрика создает семейство связанных объектов, в то время как фабричный метод создает одиночный объект.
	Абстрактная фабрика используется, когда требуется создать семейство объектов, которые взаимодействуют друг с другом,
	а фабричный метод используется, когда требуется создать объект определенного типа,
	но его конкретный класс может варьироваться в зависимости от подкласса.
*/

// выбераем какое строение будем строить
type BuildingI interface {
	Build()
}

type BuildS struct {
	develop BuildingI
}

type Nora struct {
	Door   int
	Window int
}

func (n *Nora) Build() {
	n.Door = 0
	n.Window = 0
	fmt.Println("Нора")
}

type Sauna struct {
	Door   int
	Window int
}

func (s *Sauna) Build() {
	s.Door = 1
	s.Window = 0
	fmt.Println("Сауна")
}

type House struct {
	Door   int
	Window int
}

func (h *House) Build() {
	h.Door = 1
	h.Window = 2
	fmt.Println("Дом")
}

func main() {
	home := House{}
	bb := BuildS{&home}
	bb.develop.Build()
	fmt.Println(home.Window, home.Door)
}

package main

import "fmt"

/*
Стратегия - это поведенческий паттерн, который определяет семейство алгоритмов,
инкапсулирует каждый из них и делает их взаимозаменяемыми. Он позволяет выбирать
алгоритм во время выполнения программы, в зависимости от контекста или требований.
Стратегия позволяет изолировать алгоритмы от клиентского кода, что обеспечивает
гибкость и легкость в изменении или добавлении новых алгоритмов.



 Шаги реализации
1. Определите алгоритм, который подвержен частым изменениям. Также подойдёт алгоритм, имеющий несколько вариаций, которые выбираются во время выполнения программы.
2. Создайте интерфейс стратегий, описывающий этот алгоритм. Он должен быть общим для всех вариантов алгоритма.
3. Поместите вариации алгоритма в собственные классы, которые реализуют этот интерфейс.
4. В классе контекста создайте поле для хранения ссылки на текущий объект-стратегию, а также метод для её изменения. Убедитесь в том, что контекст работает с этим объектом только через общий интерфейс стратегий.
5. Клиенты контекста должны подавать в него соответствующий объект-стратегию, когда хотят, чтобы контекст вёл себя определённым образом.

Преимущества
	 Горячая замена алгоритмов на лету.
	 Изолирует код и данные алгоритмов от остальных классов.
	 Уход от наследования к делегированию.
Недостатки
	 Реализует принцип открытости/закрытости.
	 Усложняет программу за счёт дополнительных классов.
	 Клиент должен знать, в чём разница между стратегиями, чтобы выбрать подходящую.
*/

type ExamplI interface {
	exampl(a, b int) int
}

// каждая структура реализует инфтерфес своим образом
type mult struct{}

func (m *mult) exampl(a, b int) int {
	return a * b
}

type div struct{}

func (m *div) exampl(a, b int) int {
	return a / b
}

type add struct{}

func (m *add) exampl(a, b int) int {
	return a + b
}

type sub struct{}

func (m *sub) exampl(a, b int) int {
	return a - b
}

type ExamplS struct {
	expression ExamplI
}

func (e *ExamplS) set(ex ExamplI) {
	e.expression = ex
}

func (e *ExamplS) result(a, b int) int {
	return e.expression.exampl(a, b)
}

func main() {
	a := 14
	b := 2
	ex := ExamplS{expression: &mult{}}
	fmt.Println(ex.result(a, b))
	ex = ExamplS{expression: &div{}}
	fmt.Println(ex.result(a, b))
	ex = ExamplS{expression: &add{}}
	fmt.Println(ex.result(a, b))
	ex = ExamplS{expression: &sub{}}
	fmt.Println(ex.result(a, b))
}
